# metadata.yaml for C Compilation CPU Benchmark
name: c_compile_benchmark
type: macrobenchmark
language: C
domain:
  - compilation

workloads:
  - name: gcc_compile
    summary: "GCC C compiler performance benchmark"
    action: "compile generated C source code using GCC"
    description: >
      Execute the GCC compiler to build a large set of synthetic C source files containing computationally intensive functions.
      Perform full compilation, optimization, and linking processes to generate an executable binary.
      Measure the compilation time to evaluate the CPU's performance on complex software build workloads.
    data:
      command: python3 generate_data.py
      parameters:
        num_files:
          full_name: number of files
          description: Number of .c files to generate
          default: 30
        num_funcs:
          full_name: number of functions
          description: Number of functions per file
          default: 300
        func_size:
          full_name: function size
          description: Number of lines per function
          default: 200
    command: python3 run_benchmark.py --compiler gcc
    parameters:
      opt:
        full_name: optimization level
        description: Optimization level
        default: -O3
      src_dir:
        full_name: source directory
        description: Directory to store generated source files
        default: ./data/src
      threads:
        full_name: threads
        description: Number of parallel compilation threads (independent compilations)
        default: 1
      iters:
        full_name: iterations
        description: Number of iterations to run the benchmark
        default: 3

  - name: clang_compile
    summary: "Clang C compiler performance benchmark"
    action: "compile generated C source code using Clang"
    description: >
      Execute the Clang compiler to build a large set of synthetic C source files containing computationally intensive functions.
      Perform full compilation, optimization, and linking processes to generate an executable binary.
      Measure the compilation time to evaluate the CPU's performance on complex software build workloads.
    data:
      command: python3 generate_data.py
      parameters:
        num_files:
          full_name: number of files
          description: Number of .c files to generate
          default: 30
        num_funcs:
          full_name: number of functions
          description: Number of functions per file
          default: 300
        func_size:
          full_name: function size
          description: Number of lines per function
          default: 200
    command: python3 run_benchmark.py --compiler clang
    parameters:
      opt:
        full_name: optimization level
        description: Optimization level
        default: -O3
      src_dir:
        full_name: source directory
        description: Directory to store generated source files
        default: ./data/src
      threads:
        full_name: threads
        description: Number of parallel compilation threads (independent compilations)
        default: 1
      iters:
        full_name: iterations
        description: Number of iterations to run the benchmark
        default: 3

characteristics:
  IO_effects: low
  single_machine: true
  network_effects: none
  cpu_bound: true
  memory_intensive: low

tags:
  - compilation
  - gcc
  - clang

dependencies:
  python: ">=3.8"
  gcc: ">=9.0"
  clang: ">=10.0"
