# metadata.yaml for NumPy Benchmark
name: numpy_benchmark
type: microbenchmark
language: Python
domain:
  - scientific_computing
  - linear_algebra
  - signal_processing

setup:
  command: python3 setup.py

workloads:
  - name: matmul
    summary: "Dense matrix multiplication benchmark using NumPy"
    action: "perform dense matrix multiplication with floating-point arithmetic"
    description: >
      Initialize two large dense matrices with random floating-point values.
      Execute matrix multiplication using NumPy's optimized linear algebra routines to compute the product.
      Measure the computational throughput and latency to evaluate the CPU's floating-point performance and memory bandwidth efficiency.
    command: python3 -m scripts.run_benchmark --dataset matrix
    parameters:
      size:
        full_name: matrix size
        description: Matrix dimension 
        unit: elements
        default: 4096
      iters:
        full_name: iterations
        description: Number of measured iterations
        default: 300
      warmup:
        full_name: warmup iterations
        description: Number of warmup iterations
        default: 3
      threads:
        full_name: threads
        description: Number of parallel benchmark copies
        default: 1

  - name: svd
    summary: "Singular Value Decomposition benchmark using NumPy"
    action: "compute singular value decomposition of dense matrices"
    description: >
      Generate a dense matrix with random values to serve as input for decomposition.
      Perform Singular Value Decomposition (SVD) using NumPy's linear algebra library to factorize the matrix into unitary and diagonal components.
      Assess the CPU's capability in handling complex linear algebra operations and numerical stability during intensive matrix factorizations.
    command: python3 -m scripts.run_benchmark --dataset svd
    parameters:
      size:
        full_name: matrix size
        description: Matrix dimension
        unit: elements
        default: 2048
      iters:
        full_name: iterations
        description: Number of measured iterations
        default: 100
      warmup:
        full_name: warmup iterations
        description: Number of warmup iterations
        default: 3
      threads:
        full_name: threads
        description: Number of parallel benchmark copies
        default: 1

  - name: fft
    summary: "Fast Fourier Transform benchmark using NumPy"
    action: "execute Fast Fourier Transform on signal data"
    description: >
      Generate a large 1D array representing a signal with random floating-point data.
      Compute the discrete Fourier Transform using NumPy's FFT algorithm to analyze the frequency components of the signal.
      Evaluate the CPU's performance in processing signal data and executing recursive mathematical transformations.
    command: python3 -m scripts.run_benchmark --dataset fft
    parameters:
      size:
        full_name: signal length
        description: Signal length
        unit: elements
        default: 8388608
      iters:
        full_name: iterations
        description: Number of measured iterations
        default: 1000
      warmup:
        full_name: warmup iterations
        description: Number of warmup iterations
        default: 3
      threads:
        full_name: threads
        description: Number of parallel benchmark copies
        default: 1

# Benchmark characteristics
characteristics:
  single_machine: true
  memory_effect: medium
  uses_blas: true
  IO_effects: low
  network_effects: none

# Optional tags
tags:
  - cpu
  - numpy
  - linear-algebra
  - scientific-computing

# Dependencies
dependencies:
  python: ">=3.8"
  numpy: ">=1.20"
